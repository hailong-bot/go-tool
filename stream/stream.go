package stream

import (
	"bytes"
	"encoding/gob"
)

type stream[T any] struct {
	data []T
}

// Play:
// Of generate a stream whose elements are the specified values
func Of[T any](elems ...T) stream[T] {
	return FromSlice(elems)
}

// Play:
// FromSlice generate stream from slice
func FromSlice[T any](source []T) stream[T] {
	return stream[T]{
		data: source,
	}
}

// Play:
// Generate stream where each element is generated by the provided generater function
func Generate[T any](generator func() func() (item T, ok bool)) stream[T] {
	source := make([]T, 0)

	var zeroValue T
	for next, item, ok := generator(), zeroValue, true; ok; {
		item, ok = next()
		if ok {
			source = append(source, item)
		}
	}
	return FromSlice(source)
}

// Play:
// Concat creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream.
func Concat[T any](a, b stream[T]) stream[T] {
	source := make([]T, 0)

	source = append(source, a.data...)
	source = append(source, b.data...)
	return FromSlice(source)
}

func (s stream[T]) Distinct() stream[T] {
	source := make([]T, 0)
	distinct := map[string]bool{}

	for _, v := range s.data {
		k := hashKey(v)
		if _, ok := distinct[k]; !ok {
			distinct[k] = true
			source = append(source, v)
		}
	}
	return FromSlice(source)
}

// Distinct returns a stream that removes the duplicated items.
func hashKey(data any) string {
	buffer := bytes.NewBuffer(nil)
	encoder := gob.NewEncoder(buffer)
	err := encoder.Encode(data)
	if err != nil {
		panic("stream.hashKey: get hashkey failed")
	}
	return buffer.String()
}

// Filter returns a stream consisting of the elements of this stream that match the given predicate.
func (s stream[T]) Filter(predicate func(any) bool) stream[T] {
	source := make([]T, 0)

	for _, v := range s.data {
		if predicate(v) {
			source = append(source, v)
		}
	}

	return FromSlice(source)
}

func (s stream[T]) Map(function func(T) any) stream[any] {
	source := make([]any, 0)

	for _, v := range s.data {
		convertV := function(v)
		source = append(source, convertV)
	}
	return FromSlice(source)
}
